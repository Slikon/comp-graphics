# Лабораторна робота №3: Фрактали

## Вступ

У цій лабораторній роботі ми досліджуємо та реалізуємо три різні типи фракталів:

1.  **L-системи (Системи Лінденмаєра):** На прикладі гексагональної мозаїки.
2.  **IFS (Системи ітерованих функцій):** На прикладі папороті Барнслі.
3.  **Алгебраїчні фрактали:** На прикладі множини Мандельброта.

Кожен тип фракталу демонструє різні математичні підходи до генерації складних, самоподібних структур.

## 1. L-системи: Гексагональна мозаїка

### Принцип побудови

L-системи — це формальні граматики, що використовуються для моделювання росту рослин та генерації фракталів. Вони складаються з:

*   **Аксіоми:** Початковий рядок символів.
*   **Правил продукції:** Набір правил, що визначають, як кожен символ в рядку замінюється на інший рядок символів.

Процес генерації виглядає так:
1.  Починаємо з аксіоми.
2.  Ітеративно застосовуємо правила продукції до кожного символу в поточному рядку. Кожна ітерація створює новий, довший рядок.
3.  Після заданої кількості ітерацій отриманий рядок інтерпретується як послідовність команд для графічного інструменту (в нашому випадку, `turtle`).

**Для гексагональної мозаїки (варіант 5):**

*   **Аксіома:** `"X"`
*   **Правила:**
    *   `X` -> `"[-F+F[Y]+F][+F-F[X]-F]"`
    *   `Y` -> `"[-F+F[Y]+F][+F-F-F]"`
*   **Інтерпретація символів:**
    *   `F`: Рухатися вперед на задану відстань `length`.
    *   `+`: Повернути праворуч на кут `angle` (60 градусів для гексагональної структури).
    *   `-`: Повернути ліворуч на кут `angle`.
    *   `[`: Зберегти поточну позицію та напрямок черепашки (додати в стек).
    *   `]`: Відновити останню збережену позицію та напрямок (взяти зі стеку).
    *   `X`, `Y`: Не малюються, служать для керування ростом структури.

### Пояснення коду (`L-System Fractal`)

```python
import turtle
# ... інші імпорти ...

# --- L-System Fractal (Variant 5: Hexagonal Mosaic) ---

def apply_rules(axiom, rules):
    """Applies L-system rules to the axiom string."""
    result = ""
    for char in axiom:
        result += rules.get(char, char) # Get rule for char, or char itself if no rule
    return result

def generate_l_system(iterations, axiom, rules):
    """Generates the L-system string after a number of iterations."""
    current_string = axiom
    for _ in range(iterations):
        current_string = apply_rules(current_string, rules)
    return current_string

def draw_l_system(t, instructions, angle, distance):
    """Draws the L-system using turtle graphics."""
    stack = []
    screen = t.getscreen()
    screen.tracer(0) # Turn off screen updates for faster drawing

    # Initial position adjustment
    t.penup()
    t.goto(0, -screen.window_height() / 3)
    t.pendown()
    t.setheading(90)

    for cmd in instructions:
        if cmd == \'F\':
            t.forward(distance)
        elif cmd == \'+\':
            t.right(angle)
        elif cmd == \'-\':
            t.left(angle)
        elif cmd == \'[\':
            position = t.position()
            heading = t.heading()
            stack.append((position, heading))
        elif cmd == \']\':
            if stack:
                position, heading = stack.pop()
                t.penup()
                t.goto(position)
                t.setheading(heading)
                t.pendown()
        # Ignore X and Y for drawing

    screen.update() # Update screen once drawing is complete

def run_hexagonal_mosaic(iterations=10, length=10):
    """Sets up and runs the Hexagonal Mosaic L-System."""
    axiom = "X"
    rules = {
        "X": "[-F+F[Y]+F][+F-F[X]-F",
        "Y": "[-F+F[Y]+F][+F-F-F]"
    }
    angle = 60

    l_system_string = generate_l_system(iterations, axiom, rules)

    # Setup turtle screen and turtle
    screen = turtle.Screen()
    screen.setup(width=800, height=800)
    # ... (налаштування екрану та черепашки) ...
    t = turtle.Turtle()
    # ...

    draw_l_system(t, l_system_string, angle, length)
    print(f"Finished drawing L-System. String length: {len(l_system_string)}")
```

*   `apply_rules(axiom, rules)`: Приймає поточний рядок (`axiom`) та словник правил (`rules`). Проходить по кожному символу рядка і замінює його згідно з правилами. Якщо для символу немає правила, він залишається незмінним.
*   `generate_l_system(iterations, axiom, rules)`: Генерує кінцевий рядок L-системи. Починає з аксіоми і `iterations` разів застосовує `apply_rules`.
*   `draw_l_system(t, instructions, angle, distance)`: Малює фрактал.
    *   `t`: Об\'єкт черепашки (`turtle.Turtle`).
    *   `instructions`: Рядок, згенерований L-системою.
    *   `angle`: Кут повороту.
    *   `distance`: Довжина кроку для команди `F`.
    *   Використовує стек (`stack`) для збереження та відновлення стану черепашки (команди `[` та `]`).
    *   `screen.tracer(0)` та `screen.update()` використовуються для пришвидшення малювання (зображення оновлюється лише один раз в кінці).
*   `run_hexagonal_mosaic(iterations, length)`: Головна функція для запуску L-системи.
    *   Визначає аксіому, правила та кут для гексагональної мозаїки.
    *   Генерує рядок L-системи.
    *   Налаштовує екран та черепашку.
    *   Викликає `draw_l_system` для малювання.

## 2. IFS: Папороть Барнслі

### Принцип побудови

IFS (Iterated Function System - Система ітерованих функцій) використовує набір афінних перетворень для генерації фракталу. Кожне перетворення має вигляд:

```
x_new = a*x + b*y + c
y_new = d*x + e*y + f
```

Кожному перетворенню також присвоюється ймовірність `p`.

Алгоритм генерації (іноді називається "гра хаосу"):
1.  Починаємо з довільної точки (наприклад, (0,0)).
2.  На кожній ітерації:
    а. Випадковим чином обираємо одне з афінних перетворень відповідно до їхніх ймовірностей.
    б. Застосовуємо обране перетворення до поточної точки, щоб отримати нову точку.
    в. Малюємо нову точку.
3.  Повторюємо крок 2 багато разів (наприклад, 50 000 ітерацій).

Сукупність намальованих точок утворює фрактал. Для папороті Барнслі використовуються 4 специфічні афінні перетворення, які створюють її характерну форму.

### Пояснення коду (`IFS Fractal`)

```python
import numpy as np
import matplotlib.pyplot as plt
import random
import time

# --- IFS Fractal (Variant 5: Fern) ---

def run_ifs_fractal(num_points=50000):
    """Generates and plots the Barnsley Fern IFS fractal."""
    print("\\n--- IFS Fractal: Barnsley Fern ---")

    # Коефіцієнти афінних перетворень (a, b, c, d, e, f) та їх ймовірності (p)
    transforms = [
        # T1 (стебло)
        {\'a\': 0.00, \'b\': 0.00, \'d\': 0.00, \'e\': 0.16, \'c\': 0.00, \'f\': 0.00, \'p\': 0.01},
        # T2 (основна частина листка)
        {\'a\': 0.85, \'b\': 0.04, \'d\': -0.04, \'e\': 0.85, \'c\': 0.00, \'f\': 1.60, \'p\': 0.85},
        # T3 (лівий листок)
        {\'a\': 0.20, \'b\': -0.26, \'d\': 0.23, \'e\': 0.22, \'c\': 0.00, \'f\': 1.60, \'p\': 0.07},
        # T4 (правий листок)
        {\'a\': -0.15, \'b\': 0.28, \'d\': 0.26, \'e\': 0.24, \'c\': 0.00, \'f\': 0.44, \'p\': 0.07}
    ]

    # Ймовірності та кумулятивний розподіл
    probabilities = [t[\'p\'] for t in transforms]
    cum_probs = np.cumsum(probabilities) # Для вибору перетворення

    points = np.zeros((num_points, 2)) # Масив для зберігання точок
    x, y = 0.0, 0.0 # Початкова точка

    for i in range(1, num_points):
        # Вибір перетворення на основі ймовірності
        rand_val = random.random()
        chosen_transform = None
        for j, p_cum in enumerate(cum_probs):
            if rand_val < p_cum:
                chosen_transform = transforms[j]
                break
        
        # Застосування афінного перетворення
        x_new = chosen_transform[\'a\'] * x + chosen_transform[\'b\'] * y + chosen_transform[\'c\']
        y_new = chosen_transform[\'d\'] * x + chosen_transform[\'e\'] * y + chosen_transform[\'f\']

        points[i, 0] = x_new
        points[i, 1] = y_new
        x, y = x_new, y_new # Оновлення поточної точки

    # Візуалізація за допомогою Matplotlib
    fig_ifs, ax_ifs = plt.subplots(figsize=(6, 10))
    ax_ifs.scatter(points[:, 0], points[:, 1], s=0.1, color=\'green\', marker=\'.\')
    ax_ifs.set_title("IFS: Barnsley Fern")
    # ... (налаштування вигляду графіку) ...
    ax_ifs.axis(\'off\') 
    # plt.show()
```

*   `run_ifs_fractal(num_points)`: Генерує та відображає папороть Барнслі.
    *   `transforms`: Список словників, де кожен словник містить коефіцієнти `a, b, c, d, e, f` для одного афінного перетворення та його ймовірність `p`.
    *   `probabilities` та `cum_probs`: Використовуються для випадкового вибору одного з перетворень. `np.cumsum` створює кумулятивний розподіл ймовірностей, що полегшує вибір.
    *   `points`: Масив NumPy для зберігання координат `(x, y)` згенерованих точок.
    *   Цикл `for i in range(1, num_points)`:
        *   Генерується випадкове число `rand_val`.
        *   Це число використовується для вибору перетворення: перше перетворення, чия кумулятивна ймовірність більша за `rand_val`, обирається.
        *   Нові координати `(x_new, y_new)` обчислюються за формулами афінного перетворення.
        *   Нова точка зберігається, а поточна точка оновлюється (`x, y = x_new, y_new`).
    *   `matplotlib.pyplot` використовується для візуалізації: `ax_ifs.scatter` малює хмару точок. `s=0.1` робить точки дуже маленькими, `color='green'` задає колір.

## 3. Алгебраїчні фрактали: Множина Мандельброта (Спрощене пояснення)

### Основна ідея: Гра "Чи втече точка?"

Уявіть, що ми розглядаємо кожен окремий піксель на нашому майбутньому зображенні фракталу. Кожен піксель відповідає певній точці `c` на уявній площині (комплексній площині, але для простоти думайте про неї як про звичайну координатну сітку).

Для кожної такої точки `c` ми граємо в гру:

1.  **Початкове значення:** Беремо "тестове" значення, назвемо його `z`, і воно завжди починається з нуля (`z = 0`).
2.  **Магічна формула:** Багаторазово застосовуємо просту математичну операцію:
    `новий z = (попередній z) * (попередній z) + c`

    *   На першому кроці: `z = 0*0 + c` (тобто `z` стає рівним `c`).
    *   На другому кроці: `z = (значення z з першого кроку)^2 + c`.
    *   І так далі, на кожному новому кроці ми беремо результат `z` з попереднього кроку, підносимо його до квадрату і додаємо наше початкове `c`.

3.  **Питання:** Чи "втече" значення `z` далеко?
    *   **"Втеча":** Якщо в процесі цих повторень значення `z` стає дуже великим (конкретніше, якщо його "відстань" від центру координат (0,0) стає більшою за 2), ми кажемо, що `z` "втекло".
    *   **"Залишається на місці":** Якщо `z` продовжує змінюватися, але ніколи не віддаляється від центру далі, ніж на 2 одиниці, навіть після багатьох-багатьох кроків (наприклад, 100 кроків), ми кажемо, що воно "залишається на місці" або "обмежене".

**Що таке Множина Мандельброта?**

**Множина Мандельброта — це набір усіх тих початкових точок `c`, для яких тестове значення `z` "залишається на місці" і не "втікає".**

*   Якщо для обраної точки `c` значення `z` в процесі гри "втікає", то ця точка `c` *не належить* множині Мандельброта.
*   Якщо для обраної точки `c` значення `z` "залишається на місці", то ця точка `c` *належить* множині Мандельброта.

### Як малюється зображення?

1.  **Сітка:** Наш екран або зображення — це сітка пікселів. Кожен піксель відповідає певній точці `c`.
2.  **Тестуємо кожну точку:** Для кожного пікселя (тобто для кожної точки `c`):
    *   Граємо у вищеописану гру.
    *   Рахуємо, скільки кроків знадобилося, щоб `z` "втекло".
3.  **Розфарбовування:**
    *   **Чорний колір:** Якщо `z` "залишилося на місці" (не втекло навіть після максимальної кількості кроків, наприклад, 100), то цей піксель (точку `c`) зафарбовуємо чорним. Це і є точки всередині самої множини Мандельброта.
    *   **Інші кольори:** Якщо `z` "втекло", то піксель зафарбовуємо кольором, який залежить від того, *як швидко* воно втекло. Якщо втекло дуже швидко (мало кроків) — один колір, якщо повільніше (більше кроків) — інший колір. Це створює красиві кольорові візерунки навколо чорної фігури множини.

### Пояснення коду (`Algebraic Fractal`)

```python
import numpy as np
import matplotlib.pyplot as plt
# ... інші імпорти ...

# --- Algebraic Fractal (Variant 5: Mandelbrot Set) ---

def mandelbrot(c, max_iter):
    # c: Це наша початкова точка на " координатній сітці", яку ми тестуємо.
    # max_iter: Максимальна кількість разів, яку ми будемо застосовувати формулу,
    #           перш ніж вирішимо, що z "залишається на місці".
    z = 0 # Початкове "тестове" значення z_0 = 0.
    n = 0 # Лічильник кроків гри.
    
    # Граємо, поки z не "втече" (abs(z) > 2) 
    # або поки не зробимо максимальну кількість кроків (n < max_iter).
    while abs(z) <= 2 and n < max_iter:
        z = z*z + c # Магічна формула: z_{n+1} = z_n^2 + c
        n += 1      # Збільшуємо лічильник кроків.
        
    # Повертаємо кількість кроків, за які z "втекло".
    # Якщо z не втекло, n буде дорівнювати max_iter.
    return n

def run_algebraic_fractal(width=800, height=800, x_min=-2.0, x_max=1.0, y_min=-1.5, y_max=1.5, max_iter=100):
    print("\\n--- Algebraic Fractal: Mandelbrot Set ---")

    # Створюємо " координатну сітку" точок c.
    # real: масив значень для дійсної частини c (горизонтальна вісь).
    real = np.linspace(x_min, x_max, width)
    # imag: масив значень для уявної частини c (вертикальна вісь).
    imag = np.linspace(y_min, y_max, height)
    
    # C: двовимірний масив комплексних чисел c. Кожен елемент C[i, j] - це окрема точка c.
    C = real[:, np.newaxis] + 1j * imag[np.newaxis, :] 

    # mandel_map: тут будемо зберігати, скільки кроків знадобилося для "втечі" для кожної точки c.
    mandel_map = np.zeros((width, height))
    
    # Проходимо по кожній точці c на нашій сітці.
    for i in range(width):
        for j in range(height):
            # Для кожної точки c граємо в гру і зберігаємо результат (кількість кроків).
            mandel_map[i, j] = mandelbrot(C[i, j], max_iter)

    # Малюємо зображення.
    fig_mandel, ax_mandel = plt.subplots(figsize=(8, 8))
    # imshow візуалізує масив mandel_map як картинку.
    # .T транспонує масив (повертає його), бо imshow очікує дані в іншому порядку.
    # cmap='magma' - це колірна схема.
    # origin='lower' - щоб (0,0) було внизу зліва.
    img = ax_mandel.imshow(mandel_map.T, extent=[x_min, x_max, y_min, y_max], cmap='magma', origin='lower')
    ax_mandel.set_title(f"Algebraic: Mandelbrot Set (max_iter={max_iter})")
    ax_mandel.set_xlabel("Re(c)")
    ax_mandel.set_ylabel("Im(c)")
    # Додаємо шкалу кольорів, яка показує, яка кількість ітерацій якому кольору відповідає.
    fig_mandel.colorbar(img, ax=ax_mandel, label='Iterations until divergence')
    # plt.show() # Показуємо графік (якщо не запускається разом з іншими)
```

*   **`mandelbrot(c, max_iter)`**:
    *   Ця функція — це сама "гра" для однієї точки `c`.
    *   Вона бере точку `c` і максимальну кількість спроб `max_iter`.
    *   Всередині циклу `while` вона виконує `z = z*z + c` і перевіряє, чи `abs(z)` (відстань `z` від центру) стало більше 2, або чи досягли `max_iter`.
    *   Повертає `n` — скільки кроків знадобилося для "втечі". Якщо точка не "втекла" за `max_iter` кроків, то `n` буде дорівнювати `max_iter`.

*   **`run_algebraic_fractal(...)`**:
    *   Ця функція готує все для малювання цілого зображення.
    *   `np.linspace` створює діапазони значень для реальної (`real`) та уявної (`imag`) частин точок `c`.
    *   `C = real[:, np.newaxis] + 1j * imag[np.newaxis, :]` — хитрий спосіб створити сітку всіх можливих точок `c` з комбінацій `real` та `imag`. Кожна точка `c` — це комплексне число.
    *   `mandel_map` — це "карта", де для кожної точки `c` буде записано, скільки кроків вона протрималася в "грі".
    *   Два цикли `for` пробігають по всіх точках `c` в сітці `C`. Для кожної викликається `mandelbrot()` і результат записується в `mandel_map`.
    *   `plt.imshow(...)` бере цю `mandel_map` і малює картинку, де колір кожної точки залежить від числа, записаного для неї в `mandel_map`.

## Загальний запуск (`if __name__ == "__main__":`)

```python
if __name__ == "__main__":
    print("Running Lab 3 Fractals...")

    # B) Run L-System
    print("\\n--- L-System Fractal: Hexagonal Mosaic ---")
    run_hexagonal_mosaic(iterations=4, length=5) # Зменшено кількість ітерацій для швидкості

    # C) Run IFS Fractal
    run_ifs_fractal(num_points=50000)

    # D) Run Algebraic Fractal
    run_algebraic_fractal(width=400, height=400, max_iter=50) # Зменшено розміри та ітерації для швидкості

    plt.show() # Показати всі графіки Matplotlib
```
Блок `if __name__ == "__main__":` виконується, коли скрипт запускається напряму. Він послідовно викликає функції для генерації та відображення кожного з трьох фракталів.
*   Для L-системи та множини Мандельброта параметри (кількість ітерацій, розмір) можуть бути зменшені для швидшого виконання під час демонстрації.
*   `plt.show()`: Ця команда (з `matplotlib.pyplot`) відображає всі створені графіки (папороть та множину Мандельброта). Для L-системи, яка використовує `turtle`, вікно закривається окремо. 
